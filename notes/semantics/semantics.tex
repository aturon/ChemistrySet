\documentclass[10pt]{article}

\usepackage[top=1.25in,bottom=1.25in,left=1.5in,right=1.5in]{geometry}
\usepackage{mathpazo}
\usepackage{mathpartir}

\newcommand{\ra}{\rightarrow}
\newcommand{\gives}{\vdash}
\newcommand{\proves}{\vdash}
\newcommand{\GA}{\ |\ }
\newcommand{\kw}[1]{\textsf{#1}}
\newcommand{\ty}[1]{\textrm{#1}\ }
\newcommand{\IO}{\mathbb{IO}\ }
\newcommand{\R}{\mathbb{R}\ }
\newcommand{\M}{\textit{M}\ }
\newcommand{\IOb}{\mathbb{IO}}
\newcommand{\Rb}{\mathbb{R}}
\newcommand{\Mb}{\textit{M}}
\newcommand{\bind}{\mbox{\ \scriptsize$>\!\!>\!=$\ }}
\newcommand{\letrec}[2]{\kw{letrec}\ #1\ \kw{in}\ #2}
\newcommand{\LET}[4]{\kw{let}_{#1}\ #2 = #3\ \kw{in}\ #4}

\title{Reagent semantics}
\author{Aaron Turon}

\begin{document}

\maketitle

\[
\begin{array}{rcl}
v &::=& 
      x \GA \lambda x. e \GA (v_1, \dots, v_n) \GA \pi_i \GA \kw{return}_\Mb(v) \\
c &::=& 
      v(v) \GA 
      \kw{ref}(v) \GA \kw{read}(v) \GA \kw{cas}(v,v,v) \GA 
      \kw{chan} \GA \kw{send}(v,v) \GA 
      \kw{block} \GA \kw{retry} \GA v + v  \\
  &|& \kw{react}(v) \GA \kw{dissolve}(v) \GA \kw{spawn}(v) \\     
e &::=& 
      v \GA \LET{\Mb}{x}{c}{e} \\
\tau &::=& 
      \tau \ra \tau \GA (\tau_1, \dots, \tau_n) 
  \GA \ty{ref}\tau \GA \ty{ep}(\tau, \tau') \GA \M\tau \\
\Mb &::=& \Rb \GA \IOb
\end{array}
\]
\[
\infer
  {}
  {\Gamma, x:\tau \gives x :\tau}
\qquad
\infer
  {\Gamma, x:\tau \gives e: \tau'}
  {\lambda x.e : \tau \ra \tau'}
\qquad
\infer
  {\Gamma \gives v_i : \tau_i}
  {\Gamma \gives (v_1, \dots, v_n) : (\tau_1, \dots, \tau_n)}
\qquad
\infer
  {}
  {\Gamma \gives \pi_i : (\tau_1, \dots, \tau_n) \ra \tau_i}
\]
\[
\infer
  {\Gamma \gives v : \M\tau}
  {\Gamma \gives \kw{return}_\Mb(v) : \M\tau}
\qquad
\infer
  {\Gamma \gives v_1 : \tau_2 \ra \tau \\
   \Gamma \gives v_2 : \tau_2}
  {\Gamma \gives v_1(v_2) : \tau}
\]
\[
\infer
  {\Gamma \gives v : \tau}
  {\Gamma \gives \kw{ref}(v) : \IO(\ty{ref}\tau)}
\qquad
\infer
  {\Gamma \gives v : \ty{ref}\tau}
  {\Gamma \gives \kw{read}(v) : \R\tau}
\qquad
\infer
  {\Gamma \gives v : \ty{ref}\tau \\
   \Gamma \gives v_{\rm old} : \tau \\
   \Gamma \gives v_{\rm new} : \tau}
  {\Gamma \gives \kw{cas}(v, v_{\rm old}, v_{\rm new}) : \R ()}
\]
\[
\infer
  {}
  {\Gamma \gives \kw{chan} : \IO(\ty{ep}(\tau, \tau'),\ \ty{ep}(\tau', \tau))}
\qquad
\infer
  {\Gamma \gives v: \ty{ep}(\tau, \tau') \\
   \Gamma \gives v_{\rm msg}: \tau}
  {\Gamma \gives \kw{send}(v, v_{\rm msg}) : \R\tau'}
\]
\[
\infer
  {}
  {\Gamma \gives \kw{block} : \R\tau}
\qquad
\infer
  {}
  {\Gamma \gives \kw{retry} : \R\tau}
\qquad
\infer
  {\Gamma \gives v_i : \R\tau}
  {\Gamma \gives v_1 + v_2 : \R\tau}
\]
\[
\infer
  {\Gamma \gives v: \R\tau}
  {\Gamma \gives \kw{react}(v): \IO\tau}
\qquad
\infer
  {\Gamma \gives v: \R()}
  {\Gamma \gives \kw{dissolve}(v): \IO()}
\qquad
\infer
  {\Gamma \gives v: \IO()}
  {\Gamma \gives \kw{spawn}(v): \IO()}
\]
\[
\infer
  {\Gamma \gives c : \tau_c \\\\
   \Gamma, x: \tau \gives e : \tau}
  {\Gamma \gives \LET{}{x}{c}{e} : \tau}
\qquad
\infer
  {\Gamma \gives c : \R\tau_c \\\\
   \Gamma, x: \tau \gives e : \IO(\R\tau)}
  {\Gamma \gives \LET{\R}{x}{c}{e} : \IO\tau}
\qquad
\infer
  {\Gamma \gives c : \IO\tau_c \\\\
   \Gamma, x: \tau \gives e : \IO\tau}
  {\Gamma \gives \LET{\IO}{x}{c}{e} : \IO\tau}
\]

\end{document}
